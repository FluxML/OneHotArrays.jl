var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [OneHotArrays]\nOrder   = [:function, :type]","category":"page"},{"location":"reference/#OneHotArrays.onecold","page":"Reference","title":"OneHotArrays.onecold","text":"onecold(y::AbstractArray, labels = 1:size(y,1))\n\nRoughly the inverse operation of onehot or onehotbatch:  This finds the index of the largest element of y, or each column of y,  and looks them up in labels.\n\nIf labels are not specified, the default is integers 1:size(y,1) – the same operation as argmax(y, dims=1) but sometimes a different return type.\n\nExamples\n\njulia> onecold([false, true, false])\n2\n\njulia> onecold([0.3, 0.2, 0.5], (:a, :b, :c))\n:c\n\njulia> onecold([ 1  0  0  1  0  1  0  1  0  0  1\n                 0  1  0  0  0  0  0  0  1  0  0\n                 0  0  0  0  1  0  0  0  0  0  0\n                 0  0  0  0  0  0  1  0  0  0  0\n                 0  0  1  0  0  0  0  0  0  1  0 ], 'a':'e') |> String\n\"abeacadabea\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#OneHotArrays.onehot-Tuple{Any, Any}","page":"Reference","title":"OneHotArrays.onehot","text":"onehot(x, labels, [default])\n\nReturn a OneHotVector which is roughly a sparse representation of x .== labels.\n\nInstead of storing say Vector{Bool}, it stores the index of the first occurrence  of x in labels. If x is not found in labels, then it either returns onehot(default, labels), or gives an error if no default is given.\n\nSee also onehotbatch to apply this to many xs,  and onecold to reverse either of these, as well as to generalise argmax.\n\nExamples\n\njulia> β = onehot(:b, (:a, :b, :c))\n3-element OneHotVector(::UInt32) with eltype Bool:\n ⋅\n 1\n ⋅\n\njulia> αβγ = (onehot(0, 0:2), β, onehot(:z, [:a, :b, :c], :c))  # uses default\n(Bool[1, 0, 0], Bool[0, 1, 0], Bool[0, 0, 1])\n\njulia> hcat(αβγ...)  # preserves sparsity\n3×3 OneHotMatrix(::Vector{UInt32}) with eltype Bool:\n 1  ⋅  ⋅\n ⋅  1  ⋅\n ⋅  ⋅  1\n\n\n\n\n\n","category":"method"},{"location":"reference/#OneHotArrays.onehotbatch-Tuple{Any, Any, Vararg{Any, N} where N}","page":"Reference","title":"OneHotArrays.onehotbatch","text":"onehotbatch(xs, labels, [default])\n\nReturns a OneHotMatrix where kth column of the matrix is onehot(xs[k], labels). This is a sparse matrix, which stores just a Vector{UInt32} containing the indices of the nonzero elements.\n\nIf one of the inputs in xs is not found in labels, that column is onehot(default, labels) if default is given, else an error.\n\nIf xs has more dimensions, N = ndims(xs) > 1, then the result is an  AbstractArray{Bool, N+1} which is one-hot along the first dimension,  i.e. result[:, k...] == onehot(xs[k...], labels).\n\nNote that xs can be any iterable, such as a string. And that using a tuple for labels will often speed up construction, certainly for less than 32 classes.\n\nExamples\n\njulia> oh = onehotbatch(\"abracadabra\", 'a':'e', 'e')\n5×11 OneHotMatrix(::Vector{UInt32}) with eltype Bool:\n 1  ⋅  ⋅  1  ⋅  1  ⋅  1  ⋅  ⋅  1\n ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅\n\njulia> reshape(1:15, 3, 5) * oh  # this matrix multiplication is done efficiently\n3×11 Matrix{Int64}:\n 1  4  13  1  7  1  10  1  4  13  1\n 2  5  14  2  8  2  11  2  5  14  2\n 3  6  15  3  9  3  12  3  6  15  3\n\n\n\n\n\n","category":"method"},{"location":"reference/#OneHotArrays.OneHotArray","page":"Reference","title":"OneHotArrays.OneHotArray","text":"OneHotArray{T,L,N,M,I} <: AbstractArray{Bool,M}\n\nThese are constructed by onehot and onehotbatch. Parameter I is the type of the underlying storage, and T its eltype.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OneHotArrays.OneHotMatrix-Tuple{Any, Any}","page":"Reference","title":"OneHotArrays.OneHotMatrix","text":"OneHotArray{T,L,N,M,I} <: AbstractArray{Bool,M}\n\nThese are constructed by onehot and onehotbatch. Parameter I is the type of the underlying storage, and T its eltype.\n\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#OneHotArrays.OneHotVector-Tuple{Any, Any}","page":"Reference","title":"OneHotArrays.OneHotVector","text":"OneHotArray{T,L,N,M,I} <: AbstractArray{Bool,M}\n\nThese are constructed by onehot and onehotbatch. Parameter I is the type of the underlying storage, and T its eltype.\n\n\n\n\n\n\n\n","category":"method"},{"location":"#OneHotArrays.jl","page":"Overview","title":"OneHotArrays.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"(Image: CI)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Memory efficient one-hot array encodings (primarily for use in machine-learning contexts like Flux.jl).","category":"page"},{"location":"#Usage","page":"Overview","title":"Usage","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"One-hot arrays are boolean arrays where only a single element in the first dimension is true (i.e. \"hot\"). OneHotArrays.jl stores such arrays efficiently by encoding a N-dimensional array of booleans as a (N - 1)-dimensional array of integers. For example, the one-hot vector below only uses a single UInt32 for storage.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> β = onehot(:b, (:a, :b, :c))\n3-element OneHotVector(::UInt32) with eltype Bool:\n ⋅\n 1\n ⋅","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"As seen above, the one-hot encoding can be useful for representing labeled data. The label :b is encoded into a 3-element vector where the \"hot\" element indicates the label from the set (:a, :b, :c).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"We can also encode a batch of one-hot vectors or reverse the encoding.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> oh = onehotbatch(\"abracadabra\", 'a':'e', 'e')\n5×11 OneHotMatrix(::Vector{UInt32}) with eltype Bool:\n 1  ⋅  ⋅  1  ⋅  1  ⋅  1  ⋅  ⋅  1\n ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅\n\njulia> Flux.onecold(β, (:a, :b, :c))\n:b\n\njulia> Flux.onecold([0.3, 0.2, 0.5], (:a, :b, :c))\n:c","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"In addition to functions for encoding and decoding data as one-hot, this package provides numerous \"fast-paths\" for linear algebraic operations with one-hot arrays. For example, multiplying by a matrix by a one-hot vector triggers an indexing operation instead of a matrix multiplication.","category":"page"}]
}
